# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ClassificationWithBSDDDialog
                                 A QGIS plugin
 Use the buildingSMART Data Dictionary (bSDD) to classify features and add attributes
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sebastian Schilling, HTW Dresden
        email                : sebastian.schilling@htw-dresden.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import requests
import pandas as pd
import json

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsProject,
    QgsField
)
from qgis.PyQt.QtCore import QVariant

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'classification_with_bsdd_dialog_base.ui'))


class ClassificationWithBSDDDialog(QtWidgets.QDialog, FORM_CLASS):
    classList = []
    layer = ""
    dictClass = ""

    def setApiUrl(self, url):
        global input_url
        input_url = url

    def setClassList(self, list):
        global classList
        classList = list

    def setClassSelected(self, selected):
        global classSelected
        classSelected = selected

    def setLayerSelected(self, selected):
        global layerSelected
        layerSelected = selected

    def setLayer(self, selectedLayer):
        global layer
        layer = selectedLayer
        
    def setDictClass(self, selClass):
        global dictClass
        dictClass = selClass

    def setDictUri(self, selClass):
        global dictUrl
        dictUrl = selClass
        
    def setDictionaryList(self, dictList):
        global dictionaryList
        dictionaryList = dictList      
    
    def setDictionary(self, dict):
        global dictionary
        dictionary = dict
        
    def setSelectedFeatures(self, selFeatures):
        global selectedFeatures
        selectedFeatures = selFeatures
        
    def __init__(self, parent=None):
        """Constructor."""
        super(ClassificationWithBSDDDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.setClassSelected(False)
        self.setLayerSelected(False)

        self.btnConnectToDictionary.clicked.connect(self.onConnectToDictionaryClicked)
        self.btnClassifyFeatures.clicked.connect(self.onClassifyFeaturesClicked)
        self.btnSelectAll.clicked.connect(self.onSelectAllClicked)

        layers = QgsProject.instance().mapLayers()
        layerNames = [l.name() for l in layers.values()]
        self.chooseLayer.addItems(layerNames)
        self.chooseLayer.currentIndexChanged.connect(self.onLayerChosen)


    def onConnectToDictionaryClicked(self):

        url = self.edUrlToDictionary.text()
        self.setApiUrl(url)
        
        response = requests.get(url)

        if response.status_code == 200:
            self.lblConnError.clear()
            dictionaries = response.json()
            df = pd.json_normalize(dictionaries['dictionaries'])
            self.setDictionaryList(df)
            
            self.chooseDictionary.setEnabled(True)
            self.chooseDictionary.clear()
            self.chooseDictionary.addItems(df['uri'])
            self.chooseDictionary.currentIndexChanged.connect(self.onDictionaryChosen)
        else:
            self.lblConnError.setText("Coudn't connect to the API")
            return


    def onDictionaryChosen(self):
        dictionaryUri = self.chooseDictionary.currentText()
        if dictionaryUri == "":
            return
        self.chooseClass.clear()
        self.chooseClass.setCurrentText("Choose concept ...")
        self.lblOutput.clear()
        self.lblName.clear()
        self.lblVersion.clear()
        dict = dictionaryList.loc[dictionaryList["uri"] == dictionaryUri].squeeze()
        self.setDictionary(dict)
        self.lblName.setText(dict['name'])
        self.lblVersion.setText(dict['version'])

        classesResponse = requests.get(input_url + "/classes?Uri=" + dictionaryUri)

        if classesResponse.status_code == 200:
            classes = classesResponse.json()
            df = pd.json_normalize(classes['classes'])
            
            if len(df) == 0:
                self.lblOutput.setText("No concepts found")
                return

            self.setClassList(df)
            self.chooseClass.setEnabled(True)
            self.chooseClass.addItems(df['name'])
            self.chooseClass.currentIndexChanged.connect(self.onClassChosen)

    # if class chosen
    def onClassChosen(self):
        self.setClassSelected(True)
        self.twAttributes.setRowCount(0)
        className = self.chooseClass.currentText()
        if className == "" or className == "Choose concept ...":
            return

        self.setDictClass(className) 
        con = classList.loc[classList["name"] == className].squeeze()
        self.setDictUri(con['uri'])

        # get class attributes
        classResponse = requests.get(input_url.replace("Dictionary", "Class") + "?Uri=" + con['uri'] + "&IncludeClassProperties=true")
        if classResponse.status_code == 200:
            classInstance = classResponse.json()
            try:
                classProperties = pd.json_normalize(classInstance['classProperties'])
                self.lblOutput.clear()
                self.twAttributes.setRowCount(len(classProperties))
                self.twAttributes.setColumnCount(3)
                self.twAttributes.setHorizontalHeaderLabels(["AttrbuteName", "PropertySet", "Value"])
                self.twAttributes.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
                for index, row in classProperties.iterrows():
                    self.twAttributes.setItem(index, 0, QtWidgets.QTableWidgetItem(row["name"]))
                    self.twAttributes.setItem(index, 1, QtWidgets.QTableWidgetItem(row["propertySet"]))
            except:
                self.twAttributes.setRowCount(0)
                self.lblOutput.setText("No class properties found")
        
        self.enableClassifyFeatures()

    # if layer is chosen
    def onLayerChosen(self):
        self.setLayerSelected(True)
        self.btnSelectAll.setEnabled(True)
        layers = QgsProject.instance().mapLayersByName(self.chooseLayer.currentText())
        self.setLayer(layers[0])

        self.enableClassifyFeatures()

    # enable classification button
    def enableClassifyFeatures(self):
        if layerSelected == True and classSelected == True:
            self.btnClassifyFeatures.setEnabled(True)

    def onClassifyFeaturesClicked(self):
        self.setSelectedFeatures(layer.selectedFeatureIds())
        
        shapefile = layer.storageType() == "ESRI Shapefile"
        
        # add class to selected features
        if shapefile:
            self.addContent("bSDDClass", dictClass)  
        else:
            classiBaseString = "Classification|" + dictionary["name"]
            self.addContent(classiBaseString + "|name", dictionary["name"])
            self.addContent(classiBaseString + "|source", dictionary["uri"])
            self.addContent(classiBaseString + "|version", dictionary["version"])
            self.addContent(classiBaseString + "|class|uri", dictUrl)
            self.addContent(classiBaseString + "|class|name", dictClass)
            
        # add attributes and values to selected features
        rowCount = self.twAttributes.rowCount()
            
        if rowCount > 0:
            attributes = {}

            for row in range(rowCount):
                attribute = self.twAttributes.item(row, 0).text()
                group = self.twAttributes.item(row, 1).text()
                value = ""
                try:
                    value = self.twAttributes.item(row, 2).text()
                except:
                    value = "NULL"
                attributes[attribute] = value
                
                if not shapefile:
                    if group != "":
                        self.addContent(group + "|" + attribute, value)
                    else:
                        self.addContent(attribute, value)
            
            if shapefile:        
                attributesJson = json.dumps(attributes)
                self.addContent("bSDDAttr", attributesJson)
                  
        # refresh attribute table    
        layer.reload()

    def onSelectAllClicked(self):
        layer.selectAll()
     
    # add value only to selected features   
    def addContent(self, fieldName, value):
        
        layer_provider=layer.dataProvider()
        
        # if field does not exist, add it
        if  not fieldName in layer.fields().names():
            layer_provider.addAttributes([QgsField(fieldName, QVariant.String, "character varying")])
            layer.updateFields()
 
        aIndex = layer.fields().indexFromName(fieldName)

        # update values of field       
        layer.startEditing()
        try:
            for featureId in selectedFeatures:
                s = layer_provider.changeAttributeValues({featureId: {aIndex: value}})
                if not s:
                    print(f"Failed to update feature ID: {featureId}")
                
            # Commit the changes
            if not layer.commitChanges():
                raise Exception("Failed to commit changes")
        except Exception as e:
            layer.rollBack()
            print(f"Error: {e}")
        finally:
            # Ensure the layer is updated
            layer.triggerRepaint()