# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ClassificationWithBSDDDialog
                                 A QGIS plugin
 Use the buildingSMART Data Dictionary (bSDD) to classify features and add attributes
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sebastian Schilling, HTW Dresden
        email                : sebastian.schilling@htw-dresden.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import requests
import pandas as pd

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsField
)
from qgis.PyQt.QtCore import QVariant

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'classification_with_bsdd_dialog_base.ui'))


class ClassificationWithBSDDDialog(QtWidgets.QDialog, FORM_CLASS):
    input_url = ""
    classList = []
    layerSelected = False
    classSelected = False   
     
    def setApiUrl(self, url):
        global input_url 
        input_url = url
        
    def setClassList(self, list):
        global classList
        classList = list
        
    def setClassSelected(self, selected):
        global classSelected
        classSelected = selected
    
    def setLayerSelected(self, selected):
        global layerSelected
        layerSelected = selected
        
    def __init__(self, parent=None):
        """Constructor."""
        super(ClassificationWithBSDDDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        self.setClassSelected(False)
        self.setLayerSelected(False)

        self.btnConnectToDictionary.clicked.connect(self.onConnectToDictionaryClicked)
        self.btnClassifyFeatures.clicked.connect(self.onClassifyFeaturesClicked)
        
        layers = QgsProject.instance().mapLayers()
        layerNames = [l.name() for l in layers.values()]
        self.chooseLayer.addItems(layerNames)
        self.chooseLayer.currentIndexChanged.connect(self.onLayerChosen)
        
        
    def onConnectToDictionaryClicked(self):

        url = self.edUrlToDictionary.text()
        self.setApiUrl(url)

        response = requests.get(input_url)
        dictionaries = response.json()
        
        df = pd.json_normalize(dictionaries['dictionaries'])
     
        if response.status_code == 200:
            self.chooseDictionary.setEnabled(True)
            self.chooseDictionary.clear()
            self.chooseDictionary.addItems(df['uri'])
            self.chooseDictionary.currentIndexChanged.connect(self.onDictionaryChosen)

        
    def onDictionaryChosen(self):
        dictionary = self.chooseDictionary.currentText()
        self.chooseClass.clear()
        self.chooseClass.setCurrentText("Choose concept ...")
        
        classesResponse = requests.get(input_url + "/classes?Uri=" + dictionary)
        
        if classesResponse.status_code == 200:
            classes = classesResponse.json()
            df = pd.json_normalize(classes['classes'])
            
            self.setClassList(df)
            self.chooseClass.setEnabled(True)
            self.chooseClass.addItems(df['name'])
            self.chooseClass.currentIndexChanged.connect(self.onClassChosen)
        
    def onClassChosen(self):
        self.setClassSelected(True)
        className = self.chooseClass.currentText()
        con = classList.loc[classList["name"] == className].squeeze()
        # print(con)
        # print(con["code"])
        # self.lblOutput.setText(concept["code"])
        self.enableClassifyFeatures()
        
    def onLayerChosen(self):
        self.setLayerSelected(True)
        layerName = self.chooseLayer.currentText()
        layers = QgsProject.instance().mapLayersByName(layerName)
        layer = layers[0]
        features = layer.getFeatures()
        # for feature in features:
        #     print(feature)
        #     for field in feature.fields():
        #         print(field)
        # print(layer)
        self.enableClassifyFeatures()
        
        # bSDDClass = "bSDD Class"
        # layer_provider=layer.dataProvider()
        # if  not bSDDClass in layer.fields().names():
        #     layer_provider.addAttributes([QgsField(bSDDClass, QVariant.String)])
        #     layer.updateFields()
        #     print (layer.fields().names())
        # else:
        #     print("Field " + bSDDClass + " already exists")
            
        # aIndex = layer.fields().indexFromName(bSDDClass)  
        
        # add value to each feature
        # layer.startEditing()
        # for feature in features:
        #     layer_provider.changeAttributeValues({feature.id(): {aIndex: "test"}})
        #     layer.updateFeature(feature)
        # layer.commitChanges()
        
        # add value only to selected features
        # layer.startEditing()
        # for featureId in layer.selectedFeatureIds():
        #     layer_provider.changeAttributeValues({featureId: {aIndex: "tost"}})
        # layer.commitChanges()
        
    def enableClassifyFeatures(self):
        print("Try")
        if layerSelected == True and classSelected == True:
            print("ready")
            self.btnClassifyFeatures.setEnabled(True)
            
    def onClassifyFeaturesClicked(self):
        print("Classify Features")